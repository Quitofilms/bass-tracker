<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Bass Tone & Volume Tracker v1.5</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">

    <style>
        body {
            background-color: #000;
            color: white;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; /* Prevent text selection while dragging */
        }

        /* =========================================
           TOP SECTION: Calibration & Circle
           ========================================= */
        #top-section {
            flex: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; 
            position: relative;
            background-color: #000;
            min-height: 150px; 
            padding-bottom: 10px; 
        }

        /* --- CALIBRATION SLIDER --- */
        #calibration-bar {
            position: absolute;
            top: 20px;
            width: 100%;
            height: 80px; /* Height to fit 50px text */
            z-index: 50;
            overflow: hidden; /* Mask content */
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
            display: flex;
            align-items: center;
            /* Fades on sides */
            mask-image: linear-gradient(to right, transparent, black 15%, black 85%, transparent);
            -webkit-mask-image: linear-gradient(to right, transparent, black 15%, black 85%, transparent);
        }

        #calibration-strip {
            display: flex;
            align-items: center;
            position: absolute;
            left: 50%; /* Start positioning from center */
            will-change: transform;
            cursor: grab;
        }

        #calibration-strip:active {
            cursor: grabbing;
        }

        .cal-note {
            font-size: 50px;
            font-weight: 900;
            width: 70px; /* Fixed width for calculation stability */
            text-align: center;
            flex-shrink: 0;
            transition: color 0.1s;
            line-height: 1;
            /* Text shadow for visibility */
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }

        .cal-green { color: #00ff00; opacity: 0.6; }
        .cal-yellow { color: #ffff00; transform: scale(1.1); opacity: 1; z-index: 10;}
        .cal-red { color: #ff0000; opacity: 0.6; }

        /* --- VISUALIZER --- */
        #circle {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background-color: #333;
            transition: background-color 0.1s ease;
            box-shadow: 0 0 60px rgba(0,0,0,0.6);
            margin-bottom: 5px; 
            z-index: 1;
        }

        /* =========================================
           BOTTOM SECTION: Data & Controls
           ========================================= */
        #bottom-section {
            width: 100%;
            background-color: #111; 
            border-top: 2px solid #333; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px; 
            padding-bottom: 20px;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.5);
            z-index: 20;
            flex-shrink: 0; 
        }

        #hz-display {
            font-size: 20px; 
            font-weight: normal;
            color: #888; 
            font-variant-numeric: tabular-nums;
            margin-bottom: 0px;
            line-height: 1;
        }

        #note-display {
            font-size: 50px; 
            font-weight: 900; 
            color: white;     
            line-height: 1.1;
            margin: 5px 0 10px 0;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        #status {
            font-size: 14px;
            color: #555;
            margin-bottom: 15px; 
            height: 20px;
            font-style: italic;
        }

        #controls-wrapper {
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 10px; 
            align-items: center;
        }

        #start-btn {
            width: 100%;
            padding: 12px; 
            font-size: 18px;
            font-weight: bold;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: background 0.2s;
        }
        #start-btn:hover { background: #1976D2; }

        /* Style for the Stop state */
        #start-btn.stop-active {
            background: #f44336; 
        }
        #start-btn.stop-active:hover {
            background: #d32f2f;
        }

        select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #444;
            background: #222;
            color: white;
            font-family: monospace;
            width: 100%;
            text-align: center;
            font-size: 14px;
        }

        .slider-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px; 
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #aaa;
            font-size: 12px;
            padding: 0 5px;
        }

        input[type=range] {
            flex-grow: 1;
            cursor: pointer;
            height: 6px;
            background: #444;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            margin: 0 10px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #2196F3;
            border-radius: 50%;
        }

        .button-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .adjust-btn {
            flex: 1; 
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px 0; 
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
        }

        .adjust-btn:active { background: #2196F3; border-color: #2196F3; }

        #meter-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #meter-container {
            width: 100%;
            height: 15px; 
            background-color: #222;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        #meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #FFEB3B, #F44336);
            transition: width 0.1s ease-out;
        }

        #value-display {
            font-family: monospace;
            font-size: 12px;
            color: #888;
            text-align: right;
            padding-right: 5px;
        }

        #error-msg { color: #ff5555; text-align: center; font-size: 12px; min-height: 15px;}
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="top-section">
        
        <div id="calibration-bar">
            <div id="calibration-strip">
                </div>
        </div>

        <div id="circle"></div>
    </div>

    <div id="bottom-section">
        <div id="hz-display">-- Hz</div>
        <div id="note-display">Silence</div>
        <div id="status">Ready</div>

        <div id="controls-wrapper">
            <button id="start-btn">Start</button>

            <div class="slider-container" id="sens-container">
                <div class="slider-header">
                    <span>Sensitivity</span>
                    <input type="range" id="sensitivity" min="1" max="1000" value="50">
                    <span id="sens-val">x50</span>
                </div>

                <div class="button-row">
                    <button id="sens-dec-10" class="adjust-btn">-10</button>
                    <button id="sens-dec-1" class="adjust-btn">-1</button>
                    <button id="sens-inc-1" class="adjust-btn">+1</button>
                    <button id="sens-inc-10" class="adjust-btn">+10</button>
                </div>
            </div>

            <select id="mic-select" class="hidden"></select>
            
            <div id="meter-wrapper">
                <div id="meter-container">
                    <div id="meter-fill"></div>
                </div>
                <div id="value-display">-- dB</div>
            </div>

            <div id="error-msg"></div>
        </div>
    </div>

    <script>
        // --- PWA REGISTRATION ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Service Worker registered'))
                    .catch(err => console.log('Service Worker failed', err));
            });
        }

        // --- CONFIGURATION ---
        let breakFreq = 261.63; // Start at C4
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // --- CALIBRATION SLIDER LOGIC ---
        const strip = document.getElementById('calibration-strip');
        const NOTE_WIDTH = 70; 
        const MIDI_START = 40; // E2
        const MIDI_END = 72;   // C5
        let notesElements = [];
        let currentTranslate = 0;
        let isDragging = false;
        let startX = 0;
        let startTranslate = 0;

        function initSlider() {
            for (let m = MIDI_START; m <= MIDI_END; m++) {
                const noteName = getNoteFromMidi(m);
                const el = document.createElement('div');
                el.className = 'cal-note';
                el.textContent = noteName;
                el.dataset.midi = m;
                el.dataset.freq = 440 * Math.pow(2, (m - 69) / 12);
                strip.appendChild(el);
                notesElements.push(el);
            }

            const c4Index = 60 - MIDI_START;
            currentTranslate = - (c4Index * NOTE_WIDTH) - (NOTE_WIDTH / 2);
            setTranslate(currentTranslate);
            updateCalibration();

            const container = document.getElementById('calibration-bar');
            container.addEventListener('mousedown', dragStart);
            window.addEventListener('mouseup', dragEnd);
            window.addEventListener('mousemove', drag);
            container.addEventListener('touchstart', dragStart, {passive: false});
            window.addEventListener('touchend', dragEnd);
            window.addEventListener('touchmove', drag, {passive: false});
        }

        function getNoteFromMidi(midi) {
            const note = notes[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            return note + octave;
        }

        function setTranslate(val) {
            const max = - (NOTE_WIDTH / 2); 
            const min = - ((notesElements.length - 1) * NOTE_WIDTH) - (NOTE_WIDTH / 2); 
            if (val > max + 100) val = max + 100;
            if (val < min - 100) val = min - 100;
            strip.style.transform = `translateX(${val}px)`;
        }

        function dragStart(e) {
            isDragging = true;
            startX = getPositionX(e);
            startTranslate = currentTranslate;
            strip.style.transition = 'none';
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault(); 
            const currentX = getPositionX(e);
            const diff = currentX - startX;
            currentTranslate = startTranslate + diff;
            setTranslate(currentTranslate);
            updateCalibration();
        }

        function dragEnd() {
            isDragging = false;
            strip.style.transition = 'transform 0.2s ease-out';
            let rawIndex = (-currentTranslate - (NOTE_WIDTH/2)) / NOTE_WIDTH;
            let snapIndex = Math.round(rawIndex);
            snapIndex = Math.max(0, Math.min(notesElements.length - 1, snapIndex));
            currentTranslate = - (snapIndex * NOTE_WIDTH) - (NOTE_WIDTH / 2);
            setTranslate(currentTranslate);
            updateCalibration();
        }

        function getPositionX(e) {
            return e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
        }

        function updateCalibration() {
            let centerIndex = Math.round((-currentTranslate - (NOTE_WIDTH/2)) / NOTE_WIDTH);
            centerIndex = Math.max(0, Math.min(notesElements.length - 1, centerIndex));

            notesElements.forEach((el, index) => {
                el.className = 'cal-note'; 
                if (index < centerIndex) el.classList.add('cal-green');
                else if (index > centerIndex) el.classList.add('cal-red');
                else {
                    el.classList.add('cal-yellow');
                    breakFreq = parseFloat(el.dataset.freq);
                }
            });
        }

        initSlider();

        // --- AUDIO GLOBALS ---
        let audioContext;
        let bassAnalyser;
        let volAnalyser;
        let microphone;
        let isRunning = false;
        let currentStream = null;
        let bassDataArray;
        let volDataArray;
        let silenceTimer = 0;

        // --- DOM ELEMENTS ---
        const startBtn = document.getElementById('start-btn');
        const micSelect = document.getElementById('mic-select');
        const errorMsg = document.getElementById('error-msg');
        const meterFill = document.getElementById('meter-fill');
        const valueDisplay = document.getElementById('value-display');
        const sensitivitySlider = document.getElementById('sensitivity');
        const sensValDisplay = document.getElementById('sens-val');
        const circle = document.getElementById('circle');
        const hzDisplay = document.getElementById('hz-display');
        const noteDisplay = document.getElementById('note-display');
        const statusDisplay = document.getElementById('status');

        // --- SENSITIVITY ---
        function updateSensDisplay() {
            sensValDisplay.textContent = 'x' + sensitivitySlider.value;
        }

        function adjustSensitivity(amount) {
            let current = parseInt(sensitivitySlider.value);
            let newValue = current + amount;
            newValue = Math.max(1, Math.min(1000, newValue));
            sensitivitySlider.value = newValue;
            updateSensDisplay();
            localStorage.setItem('bass_sens', newValue);
        }

        updateSensDisplay();

        sensitivitySlider.addEventListener('input', () => {
            updateSensDisplay();
            localStorage.setItem('bass_sens', sensitivitySlider.value);
        });

        document.getElementById('sens-dec-10').addEventListener('click', () => adjustSensitivity(-10));
        document.getElementById('sens-dec-1').addEventListener('click', () => adjustSensitivity(-1));
        document.getElementById('sens-inc-1').addEventListener('click', () => adjustSensitivity(1));
        document.getElementById('sens-inc-10').addEventListener('click', () => adjustSensitivity(10));

        // --- START / STOP TOGGLE ---
        startBtn.addEventListener('click', async () => {
            if (!isRunning) {
                await startAudio();
                if (isRunning) {
                    startBtn.textContent = "Stop";
                    startBtn.classList.add('stop-active');
                }
            } else {
                stopAudio();
                startBtn.textContent = "Start";
                startBtn.classList.remove('stop-active');
            }
        });

        micSelect.addEventListener('change', async (e) => {
            localStorage.setItem('bass_mic_id', e.target.value);
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            await startAudio(e.target.value);
        });

        async function startAudio(deviceId = null) {
            try {
                errorMsg.textContent = "";
                statusDisplay.textContent = "Initializing...";

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                micSelect.classList.remove('hidden');
                
                if (!deviceId) {
                    const savedMic = localStorage.getItem('bass_mic_id');
                    const savedSens = localStorage.getItem('bass_sens');
                    if (savedSens) {
                        sensitivitySlider.value = savedSens;
                        updateSensDisplay();
                    }
                    if (savedMic) deviceId = savedMic;
                }
                
                if ('wakeLock' in navigator) {
                    try { await navigator.wakeLock.request('screen'); } catch(err) {}
                }

                const constraints = { 
                    audio: { 
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false 
                    } 
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;

                if (microphone) microphone.disconnect();
                if (bassAnalyser) bassAnalyser.disconnect();
                if (volAnalyser) volAnalyser.disconnect();

                microphone = audioContext.createMediaStreamSource(stream);

                bassAnalyser = audioContext.createAnalyser();
                bassAnalyser.fftSize = 32768; 
                bassAnalyser.smoothingTimeConstant = 0.85;
                microphone.connect(bassAnalyser);
                bassDataArray = new Float32Array(bassAnalyser.frequencyBinCount);

                volAnalyser = audioContext.createAnalyser();
                volAnalyser.fftSize = 2048; 
                volAnalyser.smoothingTimeConstant = 0.3;
                microphone.connect(volAnalyser);
                volDataArray = new Float32Array(volAnalyser.fftSize);

                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.0; 
                microphone.connect(gainNode);
                gainNode.connect(audioContext.destination);

                if (micSelect.options.length === 0) {
                    await populateDeviceList();
                }

                const currentTrack = currentStream.getAudioTracks()[0];
                const settings = currentTrack.getSettings();
                if (settings.deviceId) {
                    micSelect.value = settings.deviceId;
                    localStorage.setItem('bass_mic_id', settings.deviceId);
                }

                statusDisplay.textContent = "Listening...";
                isRunning = true;
                animationLoop();

            } catch (err) {
                console.error(err);
                if (err.name === 'OverconstrainedError' && localStorage.getItem('bass_mic_id')) {
                    localStorage.removeItem('bass_mic_id');
                    return startAudio(null);
                }
                errorMsg.textContent = "Error: " + err.message;
            }
        }

        function stopAudio() {
            isRunning = false;
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            if (microphone) microphone.disconnect();
            if (bassAnalyser) bassAnalyser.disconnect();
            if (volAnalyser) volAnalyser.disconnect();

            statusDisplay.textContent = "Stopped";
            updateBassUI(0);
            meterFill.style.width = "0%";
            valueDisplay.innerHTML = "-- dB";
        }

        async function populateDeviceList() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                micSelect.innerHTML = '';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Microphone ${micSelect.length + 1}`;
                    micSelect.appendChild(option);
                });
            } catch (e) {
                console.error("Device list error", e);
            }
        }

        function animationLoop() {
            if (!isRunning) return;
            updateVolume();
            updatePitch();
            requestAnimationFrame(animationLoop);
        }

        function updateVolume() {
            volAnalyser.getFloatTimeDomainData(volDataArray);
            let sumSquares = 0.0;
            for (const amplitude of volDataArray) sumSquares += amplitude * amplitude;
            let rms = Math.sqrt(sumSquares / volDataArray.length);

            if (rms < 0.0001) {
                silenceTimer++;
                if (silenceTimer > 180) errorMsg.textContent = "No signal. Check Mic.";
            } else {
                silenceTimer = 0;
                errorMsg.textContent = "";
            }

            const boost = parseFloat(sensitivitySlider.value);
            const boostedRMS = rms * boost;
            let db = 20 * Math.log10(rms);
            if (!isFinite(db)) db = -100;
            let visualWidth = Math.min(Math.sqrt(boostedRMS), 1.0);
            meterFill.style.width = (visualWidth * 100) + "%";
            valueDisplay.innerHTML = `${Math.round(db)} dB`;
            valueDisplay.style.color = (rms === 0) ? "#555" : "#aaa";
        }

        function updatePitch() {
            bassAnalyser.getFloatFrequencyData(bassDataArray);
            const sampleRate = audioContext.sampleRate;
            const resolution = sampleRate / bassAnalyser.fftSize;
            const minBin = Math.floor(60 / resolution); 
            const maxBin = Math.floor(400 / resolution);
            
            let maxHPS = -Infinity;
            let peakBin = -1;

            for (let i = minBin; i < maxBin; i++) {
                let h1 = bassDataArray[i];              
                let h2 = bassDataArray[i * 2] || -100; 
                let h3 = bassDataArray[i * 3] || -100; 
                if (h1 < -90) continue;
                let hpsValue = h1 + (0.8 * h2) + (0.6 * h3);
                if (hpsValue > maxHPS) {
                    maxHPS = hpsValue;
                    peakBin = i;
                }
            }

            const maxVol = Math.max(...bassDataArray);
            if (maxVol < -90) {
                 updateBassUI(0);
                 return;
            }

            const fundamentalFreq = peakBin * resolution;
            determineColor(fundamentalFreq);
        }

        function determineColor(freq) {
            if (freq < 60) return; 

            const noteName = getNote(freq);
            hzDisplay.textContent = Math.round(freq) + " Hz";
            noteDisplay.textContent = noteName;

            const semitonesDiff = 12 * Math.log2(freq / breakFreq);

            if (semitonesDiff < -0.5) {
                circle.style.backgroundColor = "#00ff00"; 
                hzDisplay.style.color = "#fff";
            } else if (semitonesDiff > 0.5) {
                circle.style.backgroundColor = "#ff0000"; 
                hzDisplay.style.color = "#ff0000";
            } else {
                circle.style.backgroundColor = "#ffff00"; 
                hzDisplay.style.color = "#ffff00";
            }
        }

        function updateBassUI(freq) {
            if (freq === 0) {
                circle.style.backgroundColor = "#333";
                hzDisplay.textContent = "-- Hz";
                hzDisplay.style.color = "#555";
                noteDisplay.textContent = "Silence";
            }
        }

        function getNote(freq) {
            const noteNum = 12 * (Math.log(freq / 440) / Math.log(2));
            const noteIndex = Math.round(noteNum) + 69;
            const note = notes[noteIndex % 12];
            const octave = Math.floor(noteIndex / 12) - 1;
            return note + octave;
        }

    </script>
</body>
</html>
